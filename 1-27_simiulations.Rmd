---
title: "Adaptive Binning 1/21 Simulations"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE, warnings=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning=FALSE, message = FALSE, error=FALSE)
setwd("/Users/marco/Dropbox/Duke/projects/FLAME-binning/Adaptive-Binning/")
#source("AB_MIPs.R")
library(ggplot2)
library(reshape2)
library(dbarts)
library(RColorBrewer)
require(dbarts)
require(MatchIt)
require(beepr)
require(cem)
require(tidyverse)
source("sims.R")
#source("AB_MIP.R")
set.seed(42069)
```

## 1-D Example MIQP-Variance

```{r "simple MIQP-V p=1", cache=TRUE, results='hide'}
n = 100
n_train = n
n_test = n
p = 1
x_train = matrix(rexp(n*p, 2), n, p)
y_train = rowSums(log(x_train)) + rnorm(n, 0, 1)
x_test = matrix(rexp(n*p, 2), n, p)
y_test = rowSums(log(x_test)) + rnorm(n, 0, 1)
z_train = rep(1, n)
z_test = rep(0, n_test)
simdata = matrix(NA, n, 3* p + 2)
simdata = data.frame(simdata)
names(simdata) = c(paste("x",1:p, sep=""), 
                   paste("a", 1:p, sep=""), 
                   paste("b", 1:p, sep=""), "y", "yest")
mip_outputs = list()
for (i in 1:n){
  print(i)
  xi = x_test[i,]
  
  t1 = proc.time()[3]
  mip_pars = setup_miqp_variance(xi = xi, y_train = y_train, x_train = x_train, 
                                x_test =  x_test, lambda=2, alpha=0, m=1, M=1e5)
  t2 = proc.time()[3]
  sol = Rcplex(cvec=mip_pars$cvec, Amat=mip_pars$Amat, Qmat = mip_pars$Qmat,
               bvec=mip_pars$bvec, sense = mip_pars$sense,
               lb=mip_pars$lb, ub=mip_pars$ub,
               vtype = mip_pars$vtype, objsense = "max", control = list(trace=0))
  t3 = proc.time()[3]
  
  mip_out = recover_pars(sol, n_train, n_test, p)
  mip_outputs[[i]] = mip_out
  yest = mean(y_test[which(mip_out$w>=0.1)])
  simdata[i, ] = c(xi, mip_out$a, mip_out$b, y_test[i], yest)
  
  t4 = proc.time()[3]
  print(paste("Par generation took", round(t2 - t1, 1), 
              "seconds, solving mip took", round(t3 - t2, 1), "seconds",
              "total:", round(t4 - t1), "seconds"))
  
}
save(mip_outputs, file = '1d_miqp_output.RData')
```

```{r "simple MIQP-V p=1 plot"}
ggplot(simdata) + 
  geom_rect(aes(xmin=a1, ymin=min(y), xmax=b1, ymax=max(y)), color="black", size=0.5, alpha=0.3, fill="grey") +
  geom_point(aes(x=x1, y=y), color='red', size=2) + 
  geom_point(aes(x=x1, y=yest), color="blue") + 
  geom_point(data=data.frame(x_train, y_train),aes(x=x_train, y=y_train), pch=18) +
  xlab("x") + ylab("y") + theme_bw() + 
  theme(legend.position = c(0.8,0.2), legend.background = element_rect(color="black", size=0.5),
        legend.title = element_blank())

```

## 2D Example MIP-Predict

```{r "simple MIP-P p=2", cache=TRUE, results='hide'}
n = 100
n_train = 100
n_test = 100
p = 2
x_train = matrix(rexp(n_train*p, 2), n_train, p)
y_train = rowSums(log(x_train)) + rnorm(n_train, 0, 1)
x_test = matrix(rexp(n_test*p, 2), n_test, p)
y_test = rowSums(log(x_test)) + rnorm(n_test, 0, 1)
z_train = rep(1, n_train)
z_train[sample(1:n_train, n_train/2, replace = FALSE)] = 0
z_test = rep(0, n_test)
simdata = matrix(NA, n_test, 3* p + 2)
simdata = data.frame(simdata)
names(simdata) = c(paste("x",1:p, sep=""), 
                   paste("a", 1:p, sep=""), 
                   paste("b", 1:p, sep=""), "y", "yest")
t1 = proc.time()[3]
mip_outputs = list()
for (i in 1:n_test){
  message(paste("Matching unit", i, "of", n_test), "\r", appendLF = FALSE); flush.console()
  xi = x_test[i,]

  mip_pars = setup_mip_predict(xi = xi, zi=1, yi=y_test[i],
                               x_train=x_train, y_train = y_train, z_train=z_train,
                               x_test =  x_test[-i, , drop=F],
                               lambda1=10, lambda2=10, m=1, M=1e5)
  sol = Rcplex(cvec=mip_pars$cvec, Amat=mip_pars$Amat,
               bvec=mip_pars$bvec, sense = mip_pars$sense,
               lb=mip_pars$lb, ub=mip_pars$ub,
               vtype = mip_pars$vtype, objsense = "max", control=list(trace=0))
  mip_out = recover_pars(sol, n_train, n_test-1, p)
  mip_outputs[[i]] = mip_out
  yest = mean(y_test[-i][which(mip_out$w>=0.1)])
  simdata[i, ] = c(xi, mip_out$a, mip_out$b, y_test[i], yest)
}
print(paste("100 matches took", round(proc.time()[3] - t1, 1)))
save(mip_outputs, file='2d_mip_outputs.RData')
```

```{r "simple MIP-P p=2 plot"}
ggplot(simdata) + 
  geom_rect(aes(xmin=a1, ymin=a2, xmax=b1, ymax=b2), fill="grey", 
            color="black", size=0.5, alpha=0.3) + 
  geom_point(aes(x=x1, y=x2, color=abs(yest - y)/mean(abs(y))), size=2) + 
  scale_color_gradient(low="blue", high="red") + 
  xlab("x1") + ylab("x2") +  labs(color="% Abs. error") +  theme_bw() + 
  theme(legend.position = c(0.9,0.5), 
        legend.background = element_rect(color="black", size=0.5))
#ggsave("01-21_p=2_plot.png")
```


# Simulation 1

\begin{align*}
p = 2\\
x_{ij} &\sim Uniform(-3, 3)\\
e_i &= logit(\mathbf{x}_i^T\beta)\\
z_i &\sim Bernoulli(e_i)\\
\epsilon_i &\sim Normal(0, 1)\\
Y_i &= \alpha + z_i \mathbb{I}_{x_{i1} > 0.5}5 + \epsilon_i.
\end{align*}

```{r "sim 1", cache=T}
res = matching_sim(10, 200, 2)
res$estimator = factor(res$estimator, levels=c("MIP-Explain", "MIP-Predict", "MIQP-Variance", "Greedy", "CEM", "Full Matching" , "Nearest Neighbor", "Prognostic", "Mahalanobis"))
```

```{r "sim 1 plot"}
## Plot results
group_means <- 
  res %>%
  group_by(estimator) %>%
  summarize(mean = mean(abs(predicted - actual), na.rm = TRUE))

baseline_estimators <- c('Greedy', 'MIP-Explain', 'MIP-Predict', 'MIQP-Variance')

baseline_mean <- 
  group_means %>%
  filter(estimator %in% baseline_estimators) %>%
  pull(mean) %>%
  min()

lower_than <- group_means$mean <= baseline_mean

colors <- if_else(lower_than, 1, 2)

colors = brewer.pal(3, "Set1")[if_else(lower_than, 2, 1)]
colors[1:4] = brewer.pal(3, "Set1")[3]

ggplot(data=res) + geom_violin(aes(y=abs(predicted - actual), x=estimator, fill=estimator),
                               color="black", draw_quantiles = c(0.5), size=0.2) + 
  scale_fill_manual(values = colors) + 
  ylim(c(0, quantile(abs(res$predicted - res$actual), probs = .975, na.rm=T))) +
  xlab("") + ylab("Mean absolute estimation error") + ggtitle("Estimation error") + 
  theme_minimal() + theme(legend.position = "none")
```


# Simulation 2

\begin{align*}
p = 10\\
x_{ij} &\sim Uniform(-3, 3)\\
e_i &= logit(\mathbf{x}_i^T\beta)\\
z_i &\sim Bernoulli(e_i)\\
\epsilon_i &\sim Normal(0, 1)\\
Y_i &= \alpha + z_i \mathbb{I}_{x_{i1} > 0.5}5 + \epsilon_i.
\end{align*}

```{r "sim 2", cache=T}
res = matching_sim(10, 200, 10)
res$estimator = factor(res$estimator, levels=c("MIP-Explain", "MIP-Predict", "MIQP-Variance", "Greedy", "CEM", "Full Matching" , "Nearest Neighbor", "Prognostic", "Mahalanobis"))
```

```{r "sim 2 plot"}
## Plot results
group_means <- 
  res %>%
  group_by(estimator) %>%
  summarize(mean = mean(abs(predicted - actual), na.rm = TRUE))

baseline_estimators <- c('Greedy',  'MIP-Explain', 'MIP-Predict', 'MIQP-Variance')

baseline_mean <- 
  group_means %>%
  filter(estimator %in% baseline_estimators) %>%
  pull(mean) %>%
  min()

lower_than <- group_means$mean <= baseline_mean

colors = brewer.pal(3, "Set1")[if_else(lower_than, 2, 1)]
colors[1:4] = brewer.pal(3, "Set1")[3]

ggplot(data=res) + geom_violin(aes(y=abs(predicted - actual), x=estimator, fill=estimator),
                               color="black", draw_quantiles = c(0.5), size=0.2) + 
  scale_fill_manual(values = colors) + 
  xlab("") + ylab("Mean absolute estimation error") + ggtitle("Estimation error") + 
  theme_minimal() + theme(legend.position = "none")
```


# Simulation 3

\begin{align*}
p = 3\\
x_{ij} &\sim exponential(0.5)\\
e_i &= logit(\mathbf{x}_i^T\beta)\\
z_i &\sim Bernoulli(e_i)\\
\epsilon_i &\sim Normal(0, 1)\\
Y_i &= \alpha + z_i \mathbb{I}_{x_{i1} > 0.5}5 + \epsilon_i.
\end{align*}

```{r "sim 3", cache=T}
x_dgp = function(n, p){
  matrix(rexp(n * p, 0.5), n, p)
}
res = matching_sim(10, 200, 3, x_dgp=x_dgp)
res$estimator = factor(res$estimator, levels=c("MIP-Explain", "MIP-Predict", "MIQP-Variance", 
                                               "Greedy", "CEM", "Full Matching" , "Nearest Neighbor", 
                                               "Prognostic", "Mahalanobis"))
```

```{r "sim 3 plot"}
## Plot results
group_means <- 
  res %>%
  group_by(estimator) %>%
  summarize(mean = mean(abs(predicted - actual), na.rm = TRUE))

baseline_estimators <- c('Greedy',  'MIP-Explain', 'MIP-Predict', 'MIQP-Variance')

baseline_mean <- 
  group_means %>%
  filter(estimator %in% baseline_estimators) %>%
  pull(mean) %>%
  min()

lower_than <- group_means$mean <= baseline_mean

colors = brewer.pal(3, "Set1")[if_else(lower_than, 2, 1)]
colors[1:4] = brewer.pal(3, "Set1")[3]

ggplot(data=res) + geom_violin(aes(y=abs(predicted - actual), x=estimator, fill=estimator),
                               color="black", draw_quantiles = c(0.5), size=0.2) + 
  scale_fill_manual(values = colors) + 
  ylim(c(0, quantile(abs(res$predicted - res$actual), probs = .975, na.rm=T))) +
  xlab("") + ylab("Mean absolute estimation error") + ggtitle("Estimation error") + 
  theme_minimal() + theme(legend.position = "none")
```



# Simulation 4

\begin{align*}
p = 3\\
x_{ij} &\sim uniform(0.5)\\
e_i &= logit(\mathbf{x}_i^T\beta)\\
z_i &\sim Bernoulli(e_i)\\
\epsilon_i &\sim Normal(0, 1)\\
\mathbf{B} &= diag([0, 2, 1])\\
Y_i &= 2 + 5z_i + z_i\mathbf{x}^T\mathbf{B}\mathbf{x} + \epsilon_i.
\end{align*}

```{r "sim 4", cache=T}
HTE_dgp = function(X, Z){
  B = diag(c(0, 2, 1))
  return(Z * apply(X, 1, function(x) x %*% B %*% x))
}
y_dgp = function(X, Z, HTE){
  return(2 + 5 * Z + HTE + rnorm(nrow(X), 0, 1))
}
res = matching_sim(1, 500, 3, HTE_dgp = HTE_dgp, y_dgp=y_dgp)
res$estimator = factor(res$estimator, levels=c("MIP-Explain", "MIP-Predict", "MIQP-Variance", 
                                               "Greedy", "CEM", "Full Matching" , "Nearest Neighbor", 
                                               "Prognostic", "Mahalanobis"))
```

```{r "sim 4 plot"}
## Plot results
group_means <- 
  res %>%
  group_by(estimator) %>%
  summarize(mean = mean(abs(predicted - actual), na.rm = TRUE))

baseline_estimators <- c('Greedy',  'MIP-Explain', 'MIP-Predict', 'MIQP-Variance')

baseline_mean <- 
  group_means %>%
  filter(estimator %in% baseline_estimators) %>%
  pull(mean) %>%
  min()

lower_than <- group_means$mean <= baseline_mean

colors = brewer.pal(3, "Set1")[if_else(lower_than, 2, 1)]
colors[1:4] = brewer.pal(3, "Set1")[3]

ggplot(data=res) + geom_violin(aes(y=abs(predicted - actual), x=estimator, fill=estimator),
                               color="black", draw_quantiles = c(0.5), size=0.2) + 
  scale_fill_manual(values = colors) + 
  ylim(c(0, quantile(abs(res$predicted - res$actual), probs = .975, na.rm=T))) +
  xlab("") + ylab("Mean absolute estimation error") + ggtitle("Estimation error") + 
  theme_minimal() + theme(legend.position = "none")
```


# Simulation 5

\begin{align*}
p = 10\\
x_{ij} &\sim uniform(0.5)\\
e_i &= logit(\mathbf{x}_i^T\beta)\\
z_i &\sim Bernoulli(e_i)\\
\epsilon_i &\sim Normal(0, 1)\\
\mathbf{B} &= diag([0, 2, 1, 0, 0, 1, 1, 2, 3, 0])\\
Y_i &= 2 + 5z_i + z_i\mathbf{x}^T\mathbf{B}\mathbf{x} + \epsilon_i.
\end{align*}

```{r "sim 5", cache=T}
HTE_dgp = function(X, Z){
  B = diag(c(0, 2, 1, 0, 0, 1, 1, 2, 3, 0))
  return(Z * apply(X, 1, function(x) x %*% B %*% x))
}
y_dgp = function(X, Z, HTE){
  return(2 + 5 * Z + HTE + rnorm(nrow(X), 0, 1))
}
res = matching_sim(10, 200, 10, HTE_dgp = HTE_dgp, y_dgp=y_dgp)
res$estimator = factor(res$estimator, levels=c("MIP-Explain", "MIP-Predict", "MIQP-Variance", 
                                               "Greedy", "CEM", "Full Matching" , "Nearest Neighbor", 
                                               "Prognostic", "Mahalanobis"))
```

```{r "sim 5 plot"}
## Plot results
group_means <- 
  res %>%
  group_by(estimator) %>%
  summarize(mean = mean(abs(predicted - actual), na.rm = TRUE))

baseline_estimators <- c('Greedy', 'MIP-Explain', 'MIP-Predict', 'MIQP-Variance')

baseline_mean <- 
  group_means %>%
  filter(estimator %in% baseline_estimators) %>%
  pull(mean) %>%
  min()

lower_than <- group_means$mean <= baseline_mean

colors = brewer.pal(3, "Set1")[if_else(lower_than, 2, 1)]
colors[1:4] = brewer.pal(3, "Set1")[3]

ggplot(data=res) + geom_violin(aes(y=abs(predicted - actual), x=estimator, fill=estimator),
                               color="black", draw_quantiles = c(0.5), size=0.2) + 
  scale_fill_manual(values = colors) + 
  ylim(c(0, quantile(abs(res$predicted - res$actual), probs = .9, na.rm=T))) +
  xlab("") + ylab("Mean absolute estimation error") + ggtitle("Estimation error") + 
  theme_minimal() + theme(legend.position = "none")
```

